"""
Research analyst model for post-session analysis and insights generation.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from datetime import datetime
import uuid


@dataclass
class AnalysisReport:
    """Represents an analysis report generated by the research analyst."""
    
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    session_id: str = ""
    analyst_id: str = ""
    
    # Report content
    executive_summary: str = ""
    key_findings: List[str] = field(default_factory=list)
    participant_insights: Dict[str, str] = field(default_factory=dict)  # participant_id -> insights
    theme_analysis: Dict[str, Any] = field(default_factory=dict)
    sentiment_analysis: Dict[str, Any] = field(default_factory=dict)
    
    # Recommendations
    recommendations: List[str] = field(default_factory=list)
    next_steps: List[str] = field(default_factory=list)
    areas_for_further_research: List[str] = field(default_factory=list)
    
    # Methodology and confidence
    analysis_methodology: str = ""
    confidence_level: str = "medium"  # low, medium, high
    limitations: List[str] = field(default_factory=list)
    
    # Metadata
    created_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict:
        """Convert report to dictionary."""
        return {
            'id': self.id,
            'session_id': self.session_id,
            'analyst_id': self.analyst_id,
            'executive_summary': self.executive_summary,
            'key_findings': self.key_findings,
            'participant_insights': self.participant_insights,
            'theme_analysis': self.theme_analysis,
            'sentiment_analysis': self.sentiment_analysis,
            'recommendations': self.recommendations,
            'next_steps': self.next_steps,
            'areas_for_further_research': self.areas_for_further_research,
            'analysis_methodology': self.analysis_methodology,
            'confidence_level': self.confidence_level,
            'limitations': self.limitations,
            'created_at': self.created_at.isoformat()
        }


@dataclass
class ResearchAnalyst:
    """Represents an AI research analyst for focus group analysis."""
    
    # Identity
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    expertise_areas: List[str] = field(default_factory=list)
    
    # Analysis capabilities
    analysis_style: str = "comprehensive"  # quick, detailed, comprehensive
    focus_areas: List[str] = field(default_factory=list)  # themes, sentiment, demographics, etc.
    
    # Analysis settings
    include_sentiment_analysis: bool = True
    include_theme_extraction: bool = True
    include_participant_profiling: bool = True
    include_recommendations: bool = True
    generate_follow_up_questions: bool = True
    
    # Prompt and instructions
    base_analysis_prompt: str = ""
    custom_instructions: str = ""
    analysis_frameworks: List[str] = field(default_factory=list)
    
    # Output preferences
    report_style: str = "professional"  # academic, business, professional, casual
    detail_level: str = "detailed"  # summary, detailed, comprehensive
    include_quotes: bool = True
    include_statistics: bool = True
    
    # Metadata
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    active: bool = True
    
    def __post_init__(self):
        """Initialize analyst with default prompt if not provided."""
        if not self.base_analysis_prompt:
            self.base_analysis_prompt = self._generate_default_prompt()
    
    def _generate_default_prompt(self) -> str:
        """Generate default analysis prompt based on analyst settings."""
        expertise_str = ", ".join(self.expertise_areas) if self.expertise_areas else "qualitative research and consumer insights"
        focus_str = ", ".join(self.focus_areas) if self.focus_areas else "themes, patterns, and insights"
        frameworks_str = ", ".join(self.analysis_frameworks) if self.analysis_frameworks else "grounded theory and thematic analysis"
        
        analysis_components = []
        if self.include_sentiment_analysis:
            analysis_components.append("sentiment analysis")
        if self.include_theme_extraction:
            analysis_components.append("theme extraction") 
        if self.include_participant_profiling:
            analysis_components.append("participant profiling")
        if self.include_recommendations:
            analysis_components.append("actionable recommendations")
        
        return f"""
        You are {self.name}, an expert research analyst specializing in {expertise_str}.
        Your analysis style is {self.analysis_style} with a focus on {focus_str}.
        You use {frameworks_str} methodologies in your analysis approach.
        
        When analyzing focus group data, your analysis should include:
        {chr(10).join(['- ' + component for component in analysis_components])}
        
        ANALYSIS GUIDELINES:
        1. Provide {self.detail_level} analysis with {self.report_style} tone
        2. {"Include relevant participant quotes to support findings" if self.include_quotes else "Focus on synthesized insights without extensive quotes"}
        3. {"Include statistical summaries and quantitative insights" if self.include_statistics else "Focus primarily on qualitative insights"}
        4. Look for patterns, contradictions, and unexpected insights
        5. Consider the context and limitations of the synthetic focus group format
        6. {"Generate relevant follow-up research questions" if self.generate_follow_up_questions else "Focus on current findings without follow-up questions"}
        
        REPORTING STRUCTURE:
        - Executive Summary (key takeaways in 2-3 paragraphs)
        - Key Findings (bulleted insights with supporting evidence)
        - Theme Analysis (major themes with participant distribution)  
        - Participant Insights (individual participant patterns)
        - {"Sentiment Analysis (emotional patterns and intensity)" if self.include_sentiment_analysis else ""}
        - {"Recommendations (actionable next steps based on findings)" if self.include_recommendations else ""}
        - Methodology and Limitations
        
        Additional Instructions: {self.custom_instructions}
        
        Maintain objectivity while drawing meaningful insights that can inform decision-making.
        """.strip()
    
    def analyze_session(self, session_data: Dict[str, Any]) -> AnalysisReport:
        """Analyze a session and generate a comprehensive report."""
        # This would integrate with AI service for actual analysis
        # For now, return a template report structure
        
        report = AnalysisReport(
            session_id=session_data.get('id', ''),
            analyst_id=self.id,
            analysis_methodology=f"Automated analysis using {self.analysis_style} approach",
            confidence_level="medium"
        )
        
        # Placeholder analysis - would be replaced with actual AI analysis
        report.executive_summary = "Analysis completed using automated research methodologies."
        report.key_findings = ["Placeholder finding - actual analysis would generate real insights"]
        report.recommendations = ["Placeholder recommendation - actual analysis would generate actionable recommendations"]
        
        return report
    
    def answer_research_question(self, question: str, session_data: Dict[str, Any], context: str = "") -> str:
        """Answer a specific research question based on session data."""
        # This would integrate with AI service to answer specific questions
        # For now, return a template response
        return f"Based on the focus group data analysis, here is the response to: '{question}' - [This would contain the actual AI-generated response based on the session data and context.]"
    
    def generate_follow_up_study_suggestions(self, session_data: Dict[str, Any]) -> List[str]:
        """Generate suggestions for follow-up studies based on current findings."""
        # This would analyze the session and suggest follow-up research
        suggestions = [
            "Conduct deeper exploration of emerging themes with additional participants",
            "Validate findings through quantitative survey with larger sample",
            "Explore demographic differences through targeted focus groups"
        ]
        return suggestions
    
    def update_prompt(self) -> None:
        """Update the analysis prompt and timestamp."""
        self.base_analysis_prompt = self._generate_default_prompt()
        self.updated_at = datetime.now()
    
    def to_dict(self) -> Dict:
        """Convert analyst to dictionary for serialization."""
        return {
            'id': self.id,
            'name': self.name,
            'expertise_areas': self.expertise_areas,
            'analysis_style': self.analysis_style,
            'focus_areas': self.focus_areas,
            'include_sentiment_analysis': self.include_sentiment_analysis,
            'include_theme_extraction': self.include_theme_extraction,
            'include_participant_profiling': self.include_participant_profiling,
            'include_recommendations': self.include_recommendations,
            'generate_follow_up_questions': self.generate_follow_up_questions,
            'base_analysis_prompt': self.base_analysis_prompt,
            'custom_instructions': self.custom_instructions,
            'analysis_frameworks': self.analysis_frameworks,
            'report_style': self.report_style,
            'detail_level': self.detail_level,
            'include_quotes': self.include_quotes,
            'include_statistics': self.include_statistics,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat(),
            'active': self.active
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'ResearchAnalyst':
        """Create analyst from dictionary."""
        # Handle datetime fields
        if 'created_at' in data and isinstance(data['created_at'], str):
            data['created_at'] = datetime.fromisoformat(data['created_at'])
        if 'updated_at' in data and isinstance(data['updated_at'], str):
            data['updated_at'] = datetime.fromisoformat(data['updated_at'])
            
        return cls(**data)